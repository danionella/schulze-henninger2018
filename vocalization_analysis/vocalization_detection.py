#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""
Functions to detect acoustic pulses generated by Danionella translucida.

Optimized for Python 2.7
+ helper functions
"""

import numpy as np
import scipy.signal as sig
import soundfile
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
from matplotlib.ticker import FormatStrFormatter
from matplotlib.ticker import MultipleLocator
from matplotlib import lines as mpllines

###############################################################################

# parameters for Danionella pulse extractions
check_conditions = dict(max_width=0.012,
                        min_width=0.0003,
                        min_size=0.0005,
                        baseline_factor=0.25,
                        max_search_width = 0.2,
                        width_amp_factor=0.15,
                        min_gradient=8.5)

def run_demo():
    fn = 'Fig2E_raw.wav'
    sf = soundfile.SoundFile(fn, 'r')
    samplerate = sf.samplerate
    frames = len(sf)
    channels = sf.channels
    data = sf.read(frames)
    raw = data

    # ###########################
    # DETECTION OF VOCALIZATIONS
    
    # temporal filtering
    highpassf=1000.
    lowpassf=10000.
    data = highpass_filter(samplerate, data, highpassf, order=5)
    data = lowpass_filter(samplerate, data, lowpassf, order=5)

    # calculate envelope
    env = envelope(samplerate, data, window_size=0.0015, gauss=True)  
    tvec = np.arange(data.size, dtype=float)/samplerate

    signal_thresh = 0.01
    check_conditions['min_peak_amp'] = signal_thresh
    print('Signal threshold at: {:.5f}'.format(signal_thresh))
    check_conditions['freq'] = samplerate

    info, pulses = pulse_detector(tvec, env, check_conditions=check_conditions)  # event detector
    print('{0} pulses detected.\n'.format(pulses.shape[0]))

    # Burst detection
    pulsetimes = pulses[:,1]
    burst_inx = find_bursts(pulsetimes)
    bursts = [pulses[burst_inx[i]:burst_inx[i+1],:] for i in xrange(len(burst_inx)-1)]

    # ###########################
    # PLOT WAVEFORM AND DETECTIONS

    # limit field of view to the vocalizations
    startt = 0.395
    stopt = 2.82

    ## clean up: removal of small after-pulses
    pulses = np.vstack(bursts)
    pinx = (startt<=pulses[:,1])&(stopt>=pulses[:,1])
    pulses = (pulses[pinx]-startt)*1000
    cleanpulsetimes = pulses[:,1]
    burst_inx = find_bursts(cleanpulsetimes/1000)
    cleanbursts = [pulses[burst_inx[i]:burst_inx[i+1],:] for i in xrange(len(burst_inx)-1)]

    pulsetimes = pulses[:,1]
    burst_inx = find_bursts(pulsetimes)
    bursts = [pulses[burst_inx[i]:burst_inx[i+1],:] for i in xrange(len(burst_inx)-1)]

    # waveform for visualization
    highpassf=150.
    lowpassf=10000.
    data = highpass_filter(samplerate, raw, highpassf, order=5)
    data = lowpass_filter(samplerate, data, lowpassf, order=5)

    dinx = (tvec>=startt)&(tvec<=stopt)
    xdata = data[dinx]
    xtvec = np.arange(xdata.size, dtype=float)/samplerate*1000

    colors = ['#f18a00', '#1c719d','#5a3499','#ba2d16','#bcb600','#F1B500']

    fig = plt.figure(figsize=(16./2.54, 2./2.54))
    params = {'font.size': 8,
              'axes.labelsize': 8,
              'axes.linewidth': .4,
              'ytick.labelsize': 8,
              'xtick.labelsize': 8}
    plt.rcParams.update(params)

    # Plot waveform
    gs = gridspec.GridSpec(1, 1)
    gs.update(left=0.07, right=0.98, top=0.5, bottom=0.00, hspace=0.2, wspace=0.2)
    ax = fig.add_subplot(gs[0, 0])

    ax.plot(xtvec, xdata/np.max(xdata)*0.7, '-k', linewidth=.4)

    ax.set_xlabel('Time [ms]', labelpad=1)
    ax.xaxis.set_major_formatter(FormatStrFormatter('%g'))
    ax.axis('off')
    ax.set_xlim(xtvec[0], xtvec[-1])
    ax.set_xlim(-1, 1)
    adjust_spines(ax, ['bottom'])

    # Plot instant frequency
    gs = gridspec.GridSpec(1, 1)
    gs.update(left=0.07, right=0.98, top=.92, bottom=0.5, hspace=0.2, wspace=0.2)
    axf = fig.add_subplot(gs[0, 0], sharex=ax)

    for burst in cleanbursts:
        # detected pulses
        ax.plot(burst[:,1], burst[:,1]*0.+.9, '.', color=colors[3], markersize=1)
        # instant frequency
        ifreq = 1000./np.diff(burst[:,1])
        itimes = burst[:-1,1]+np.diff(burst[:,1])/2
        if ifreq.size >= 2:
            axf.step(itimes, ifreq, '-k', where='mid', linewidth=.7, markersize=2, color=colors[1])
        else:
            axf.step(itimes, ifreq, '.k', where='mid', linewidth=.7, markersize=2, color=colors[1])

    axf.annotate('I.F. [Hz]', (0.01, .72),
            xycoords='figure fraction', rotation='vertical',
            horizontalalignment='center', verticalalignment='center')

    axf.set_yticks([50, 150])
    axf.set_ylim([50, 150])
    axf.set_xlim(xtvec[0], xtvec[-1])
    axf.yaxis.set_minor_locator(MultipleLocator(100))
    adjust_spines(axf, ['left'])
    ticks_outward(axf, pad=6)

    # plot marker for time
    gs = gridspec.GridSpec(1, 1)
    gs.update(left=0.01, right=0.92, top=.07, bottom=0.001, hspace=0.2, wspace=0.2)
    axl = fig.add_subplot(gs[0, 0], sharex=ax)

    x = np.array([0.0, 100])+8
    y = [.5, .5]
    axl.plot(x,y, color='k', lw=2)
    axl.axis('off')
    axl.set_ylim(0., 1)
    axl.set_xlim(xtvec[0], xtvec[-1])
    axl.annotate(r'100$\,$ms', (0.035, .04), xycoords='figure fraction', 
        horizontalalignment='center', verticalalignment='bottom')

    fn = 'vocalizations'
    # plt.show()
    plt.savefig(fn+'.pdf', dpi=300)
    plt.savefig(fn+'.png', dpi=300)
    plt.close('all')


###############################################################################
# ANALYSIS HELPERS

def find_bursts(pulsetimes, cutoff_interval=0.025):
    """
    Function for identifying burst, based on cutoff_interval
    pulsetimes: array of pulsetimes
    cutoff_interval: time between bursts, in seconds
    """
    interval = np.diff(pulsetimes)
    # find gaps between bursts
    gaps = np.where(interval > cutoff_interval)[0]
    # extend by start and end
    bout_inx = np.hstack([[0], gaps+1, [len(pulsetimes)]])
    # burst-length
    bout_l = np.diff(bout_inx)
    print('Number of bursts found: {}'.format(len(bout_l)))
    return bout_inx


###############################################################################
# GENERAL HELPERS

def envelope(rate, data, window_size=0.0015, gauss=False):
    print('generating envelope (t={:.3f}s) ...'.format(window_size))
    from scipy.signal import gaussian

    rstd_window_size_time = window_size  # s
    rstd_window_size = int(rstd_window_size_time * rate)
    # define kernel shape
    if gauss:
        w = 1.0 * gaussian(rstd_window_size, std=rstd_window_size/7)
    else:
        w = 1.0 * np.ones(rstd_window_size)
    w /= np.sum(w)
    rstd = (np.sqrt((np.correlate(data ** 2, w, mode='same') -
                     np.correlate(data, w, mode='same') ** 2)).ravel()) * np.sqrt(2.)
    return rstd

def highpass_filter(rate, data, cutoff, order=3, verbose=True):
    print('highpass ...')
    data = data.ravel()
    nyq = 0.5*rate
    high = cutoff/nyq
    b, a = sig.butter( 4, high, btype='highpass' )
    # plot filter function, with matplotlib
    ## w, h = sig.freqz(b, a)
    ## plt.semilogx(w, 20 * np.log10(abs(h)))
    ## plt.show()
    for o in xrange(order):
        fdata = sig.lfilter( b, a, data )
    return fdata

def lowpass_filter(rate, data, cutoff, order=3, verbose=True) :
    print('lowpass ...')
    data = data.ravel()
    nyq = 0.5*rate
    low = cutoff/nyq
    b, a = sig.butter( 4, low, btype='lowpass' )
    # plot filter function, with matplotlib
    ## w, h = sig.freqz(b, a)
    ## plt.semilogx(w, 20 * np.log10(abs(h)))
    ## plt.show()
    for o in xrange(order):
        fdata = sig.filtfilt(b, a, data)
    return fdata

###############################################################################
# EVENT DETECTION

def pulse_detector(t, data, check_conditions=None):
    print('detecting pulses ... ')
    n = len(data)
    threshold = 0.0001
    info, all_peaks = detect_peaks(t, data, threshold, 
        check_func=accept_peaks, check_conditions=check_conditions)
    return info, all_peaks


def detect_peaks( time, data, threshold, check_func=None, check_conditions=None):
    """
    Peak detection algorithm based on 
    Todd B, Andrews D (1999) The identification of peaks in physiological signals. Comput Biomed Res 32:322â€“335.
    as implemented by

    """
    if not check_conditions:
        check_conditions = dict()
        
    event_list = list()

    info = list()  # dummy for returning data on detected events

    # initialize:
    dir = 0
    min_inx = 0
    max_inx = 0
    min_value = data[0]
    max_value = min_value
    trough_inx = 0

    # loop through the new read data
    for index, value in enumerate(data):

        # rising?
        if dir > 0:
            # if the new value is bigger than the old maximum: set it as new maximum
            if max_value < value:
                max_inx = index  # maximum element
                max_value = value

            # otherwise, if the maximum value is bigger than the new value plus the threshold:
            # this is a local maximum!
            elif max_value >= value + threshold:
                # there was a peak:
                event_inx = max_inx

                # check and update event with this magic function
                if check_func:
                    info, r = check_func( time, data, event_inx, index, trough_inx, min_inx, threshold, check_conditions)
                    if len( r ) > 0 :
                        # this really is an event:
                        event_list.append( r )
                else:
                    # this really is an event:
                    event_list.append( time[event_inx] )

                # change direction:
                min_inx = index  # minimum element
                min_value = value
                dir = -1

        # falling?
        elif dir < 0:
            if value < min_value:
                min_inx = index  # minimum element
                min_value = value
                trough_inx = index

            elif value >= min_value + threshold:
                # there was a trough:
                # change direction:
                max_inx = index  # maximum element
                max_value = value
                dir = 1

        # don't know!
        else:
            if max_value >= value + threshold:
                dir = -1  # falling
            elif value >= min_value + threshold:
                dir = 1  # rising

            if max_value < value:
                max_inx = index  # maximum element
                max_value = value

            elif value < min_value:
                min_inx = index  # minimum element
                min_value = value
                trough_inx = index
    data = np.array(event_list) if len(event_list) else []
    return info, data

def accept_peaks(x, data, peak_inx, index, through_inx, min_inx, threshold, check_conditions):
    """
    Accept each detected peak and compute its size and width.

    Args:
        x (array): time, frequency, ... ?
        data (array): the data
        peak_inx: index of the current peak
        index: current index (first minimum after peak at threshold below)
        through_inx: index of the previous trough
        min_inx: index of previous minimum
        threshold: threshold value
    
    Returns: 
        xval (float): x value of the peak
        yval (float): value of data at the peak)
        size (float): size of the peak (peak minus previous trough)
        width (float): width of the peak at 0.75*size
        count (float): zero
    """

    # data is demeaned, so we can assume that it is centered around 0
    ## -> size is defined as height above 10 percent peak-value
    ## -> width is defined as span of the peak above 10 percent peak-value

    # refuse if the peak is too small
    # if not data[peak_inx] > minimum_value:
    if not data[peak_inx] > check_conditions['min_peak_amp']:
        return None, []

    # refuse tiny bumps
    # refuse if: data[peak_inx] - data[-min_inx] < data[peak_inx]*0.5
    thresh = data[peak_inx]*0.5
    if data[peak_inx] - data[min_inx] < thresh:
        return None, []

    # calculating width
    max_search_width = check_conditions['max_search_width']  # sec
    max_search_inx = int(round(max_search_width * check_conditions['freq']))

    baseline = data[through_inx]
    size = data[peak_inx]-data[through_inx]
    thresh = baseline+check_conditions['width_amp_factor']*size

    # check for minimal size
    if size < check_conditions['min_size']:
        return None, []
    # left side
    locminx = peak_inx
    for k in xrange(peak_inx, max([peak_inx-max_search_inx,0]), -1):
        if data[k] < data[locminx]: locminx = k
        if data[k] <= thresh:
            break
        # break point: if thresh can not reached, take local minimum
        ## note: 1st condition due to non-optimal peak detector that may not be the highest peak 
        elif data[locminx] < data[peak_inx]-size*.3 and data[k] > data[peak_inx]:
            k = data[k:peak_inx].argmin()+k
            break
        elif data[k] > 1.5*data[peak_inx]:
            return None, []
    leftinx = k
    leftx = x[k]
    
    # right side
    locminx = peak_inx
    for k in xrange(peak_inx, min([peak_inx+max_search_inx,len(data)])):
        if data[k] < data[locminx]: locminx = k
        if data[k] <= thresh:
            break
        # break point: if thresh can not reached, take local minimum
        ## note: 1st condition due to non-optimal peak detector that may not be the highest peak 
        elif data[locminx] < data[peak_inx]-size*.3 and data[k] > data[peak_inx]:
            k = data[peak_inx:k].argmin()+peak_inx
            break
        elif data[k] > 1.5*data[peak_inx]:
            return None, []
    rightinx = k
    rightx = x[k]

    # check against some conditions
    width = rightx - leftx
    if np.abs(width) >= check_conditions['max_width'] or \
        np.abs(width) <= check_conditions['min_width']:
        return None, []

    info = ['index of peak', 
            'x-value of peak', 
            'y-value of peak',
            'size of peak',
            'width of peak',
            'first index of peak',
            'x-value of first index of peak',
            'last index of peak',
            'x-value of last index of peak']
    data = peak_inx, x[peak_inx], data[peak_inx], size, width, leftinx, leftx, rightinx, rightx
    return info, data


###############################################################################
###############################################################################
# HELPER FUNCTIONS

# FUNCTIONS TO MODIFY PLOTS
def adjust_spines(ax, spines, dropped=False):
    for loc, spine in ax.spines.items():
        if loc in spines:
            if dropped:
                spine.set_position(('outward', 10))  # outward by 10 points
                spine.set_smart_bounds(True)
        else:
            spine.set_color('none')  # don't draw spine

    # turn off ticks where there is no spine
    if 'left' in spines:
        ax.yaxis.set_ticks_position('left')
    else:
        # no yaxis ticks
        plt.setp(ax.get_yticklabels(), visible=False)
        plt.setp(ax.get_yticklines(), visible=False)

    if 'bottom' in spines:
        ax.xaxis.set_ticks_position('bottom')
    else:
        # no xaxis ticks
        plt.setp(ax.get_xticklabels(), visible=False)
        plt.setp(ax.get_xticklines(), visible=False)

def ticks_outward(ax, tickshift = -0.015, two_y_scales=False, pad=8):
    box_off(ax, two_y_scales=two_y_scales)
    for tick in ax.get_yaxis().get_major_ticks():
        tick.set_pad(pad)
    for tick in ax.get_yaxis().get_minor_ticks():
        tick.set_pad(pad)
    for tick in ax.get_xaxis().get_major_ticks():
        tick.set_pad(pad)
    for tick in ax.get_xaxis().get_minor_ticks():
        tick.set_pad(pad)
    for line in ax.get_xticklines():
        line.set_marker(mpllines.TICKDOWN)
    for line in ax.get_yticklines():
        line.set_marker(mpllines.TICKLEFT)
    for line in ax.xaxis.get_minorticklines():
        line.set_marker(mpllines.TICKDOWN)
    for line in ax.yaxis.get_minorticklines():
        line.set_marker(mpllines.TICKLEFT)

def box_off(ax, two_y_scales=False):
    for loc, spine in ax.spines.iteritems():
        if loc in ['left', 'bottom']:
            pass
        elif loc in ['right', 'top']:
            if 'right' and two_y_scales:
                continue
            spine.set_color('none')  # don't draw spine
        else:
            raise ValueError('unknown spine location: %s'%loc)
    ax.xaxis.set_ticks_position('bottom')
    ax.yaxis.set_ticks_position('left')



###############################################################################

if __name__ == '__main__':
    run_demo()
